
### 页面流程优化

#### 流程图节点
如下图所示
![请求渲染流程](/mdsource/img/页面请求流程图.png)

#### 请求数量的减小
包括是利用webpack的工具采用合并策略

#### 请求体积的减小
1.压缩策略<br>
2.懒加载方案，对代码进行切分<br>

#### 缓存策略

1.采用强缓存方案<br>
2.采用协商缓存方案<br>
3.也包括一些类似localstorage 本地数据库<br>

强缓存和协商缓存基于浏览器缓存

`浏览器缓存`是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。

缓存文件校验流程图如下<br>
![文件校验](/mdsource/img/缓存校验过程.png)


1. 浏览器请求某一资源时，会先获取该资源缓存的header信息，然后根据header中的Cache-Control和Expires来判断是否过期。若没过期则直接从缓存中获取资源信息，包括缓存的header的信息，所以此次请求不会与服务器进行通信。这里判断是否过期，则是强缓存相关。后面会讲Cache-Control和Expires相关。

2. 如果显示已过期，浏览器会向服务器端发送请求，这个请求会携带第一次请求返回的有关缓存的header字段信息，比如客户端会通过If-None-Match头将先前服务器端发送过来的Etag发送给服务器，服务会对比这个客户端发过来的Etag是否与服务器的相同，若相同，就将If-None-Match的值设为false，返回状态304，客户端继续使用本地缓存，不解析服务器端发回来的数据，若不相同就将If-None-Match的值设为true，返回状态为200，客户端重新机械服务器端返回的数据；客户端还会通过If-Modified-Since头将先前服务器端发过来的最后修改时间戳发送给服务器，服务器端通过这个时间戳判断客户端的页面是否是最新的，如果不是最新的，则返回最新的内容，如果是最新的，则返回304，客户端继续使用本地缓存。

```
以上是请求资源上。 在页面资源方面，向我们的CSS js资源放到static服务器上，
对此做缓存处理。 针对img图片则采用放到阿里云上的方案
```

#### dom结构首屏渲染问题
1. 对于我们的页面结构体，刚开始渲染的时候肯定不会希望DOM节点过多， 常采用滑动加载下一页或者是异步载入非首屏的方案
2. 采用骨架策略，首屏先有后台渲染出页面布局样式的DOM模板，前台请求到数据后再进行数据的填充
3. 对于img图片也可以采用懒加载策略

#### js交互触发页面的渲染

1. 对于涉及多个节点变动的，可以采用异步事件方案，现将所需要渲染的对象方法依次push到事件队列当中，最后统一渲染。
2. 对于要一次生成多个节点的可以采用fragment(文档片段)
3. 也可以利用web work另外开启一个线程处理一些计算密集型或高延迟的任务

#### WebWorker
web worker使用时有一下几个注意点
1. 同源限制
分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。
2. DOM 限制
Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。
3. 通信联系
Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。
4. 脚本限制
Worker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。
5. 文件限制
Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。
