### 浏览器内核

#### 浏览器线程及关系
![线程种类图](/mdsource/img/browsercore1.png)

*GUI渲染线程与JS引擎线程互斥*

由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。

因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起，GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。

*JS阻塞页面加载*

从上述的互斥关系，可以推导出，JS如果执行时间过长就会阻塞页面。

譬如，假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。
然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。

所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。

*WebWorker，JS的多线程？*

前文中有提到JS引擎是单线程的，而且JS执行时间过长会阻塞页面，那么JS就真的对cpu密集型计算无能为力么？

所以，后来HTML5中支持了Web Worker。

MDN的官方解释是：
<div class="wrapper-text">
Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面  一个worker是使用一个构造函数创建的一个对象(e.g. Worker()) 运行一个命名的JavaScript文件   这个文件包含将在工作线程中运行的代码; workers 运行在另一个全局上下文中,不同于当前的window  因此，使用 window快捷方式获取当前全局的范围 (而不是self) 在一个 Worker 内将返回错误
</div>

* 创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）
* JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）
所以，如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程，
只待计算出结果后，将结果通信给主线程即可。

而且注意下，`JS引擎是单线程的`，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。

#### HTML解释器和DOM模型

*渲染流程图*<br>
![流程图](/mdsource/img/browsercore2.png)

有上图可知，渲染主要分为以下几个步骤
1. 读取HTML文件，解析并生成DOM树
2. 读取CSS文件，解析生成样式规则表，并根据选择器找到元素的匹配规则
3. 由DOM树和匹配规则生成RenderObject树，并进行布局和绘制
4. 执行JavaScript时，可能会改变DOM结构和CSS样式，此时需要针对改变部分重新布局和绘制。


*DOM模型*<br>
DOM定义了文档上的对象，对象的行为和属性，以及这些对象之间的关系。DOM树可以认为是页面上数据和结构的一个树形表示。HTML DOM定义了所有HTML文档元素的对象和属性，以及访问他们的方法。
![流程图](/mdsource/img/browsercore3.png)
节点
HTML文档每一个成分都是一个节点。整个文档对应HTMLDocument，称为文档节点。每个HTML标签是一个元素节点HTMLElement，又分为HTMLBodyElement，HTMLDIvElement, HTMLImageElement等对象。每一个属性是一个属性节点Attr。下图是一个简单的DOM树

*HTML解析流程分析*<br>
流程图如下所示<br>
![流程图](/mdsource/img/browsercore4.png)

解析读取HTML文件字节流，最终生成DOM树，大概分为以下四个步骤：<br>

1. 字节流转变为字符流。根据编码时候的格式来相应解码，如UTF-8 GBK
2. 词法分析，可以简单理解为将字符流解析为一个个单词。这些单词在HTML语言的词汇表中（其实对于所有编程语言的词法分析阶段都是将符号解析为相应语言的词汇表中的单词）。这个过程会跳过空格，换行等内容。词法分析由HTMLTokenizer完成，循环调用nextToken()方法，解析出所有词语。HTMLToken定义了6种词语，DOCTYPE, StartTag, EndTag, Comment, Character, EndOfFile。

3. 语法分析，利用HTML语言的语法对单词进行语法匹配。这个过程是迭代式的。获取单词，然后进行语法匹配。如果匹配，则将其添加到解析树上。如果未匹配，则保存在堆栈中，然后去获取下一个单词，直到匹配为止。如果最终还未匹配，则抛出异常。

4. 转换，将解析树转变为DOM树。根据DOM模型，创建相关的DOM节点对象。HTMLDocument对象是DOM树的根节点，HTMLBodyElement代表body节点，HTMLDivElement代表div元素节点，Attr代表属性节点。

#### DOM事件机制

事件处理主要有事件捕获和事件冒泡两种机制，过程如下：

![流程图](/mdsource/img/browsercore5.png)

当渲染引擎接收到一个事件的时候，会通过HitTest检查哪个元素是直接的事件目标，以上图“img”为例，假设它是事件的直接目标，这样事件会经过自顶向下和自底向上两个过程.<br>
`事件的捕获`是向下的，事件先到document节点，然后一路到达目标节点，事件可以在这一传递过程中被捕获，只需要在注册监听的时候设置相应的参数即可，EventTarget类中的“addEventListener”的第三个参数就是表示这个含义，默认情况下，其他节点不捕获这样的事件，如果网页注册了这样的监听者，那么监听者的回调函数会被调用，函数可以通过事件的“stopPropagation”函数来阻止事件向下传递。<br>
`事件的冒泡`过程是从下向上的顺序，它的默认行为是不冒泡，但是事件包含一个是否冒泡的属性，当这一属性为真的时候，渲染引擎会将该事件首先传递给事件目标节点的父亲，以此类推，同捕获动作一样，这些监听函数也可以使用“stopPropagation”函数来阻止事件向上传递。

#### 影子(Shadow)DOM

影子DOM主要是解决了一个文档中可能需要大量交互的多个DOM树建立和维护各自的功能边界的问题，影子DOM能够使得一些DOM节点在特定范围内可见，而在网页的DOM树中却不可见，但是网页渲染结果中包含了这些节点。<br>
下图描述了HTML文档对应的DOM树和”div”元素包含的一个影子DOM子树

![流程图](/mdsource/img/browsercore6.png)

当使用JavaScript代码访问HTML文档的DOM树的时候，通常的接口是不能直接访问到影子DOM树中的节点的，JavaScript只能通过特殊的接口方式。HTML5对视频、音频提供了支持，这些元素有很复杂的控制界面组成，这些界面也是使用HTML元素编写，但是在DOM树中，无法找到相应的节点，这就是采用了影子DOM的思想，影子DOM中，所有事件目标都是包含影子DOM子树的节点对象，事件捕获的逻辑没有发生变化，在影子DOM子树内也会继续传递，当影子DOM子树中的事件向上冒泡的时候，WebKit会同时向整个文档的DOM上传递该事件。

#### asycn和deffer

script解析时的执行策略如下图所示

![流程图](/mdsource/img/browsercore7.png)
