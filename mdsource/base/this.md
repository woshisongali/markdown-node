### 关于this


#### 解释作用域

作用域是根据名称查找变量的一套规则， 当一个块或函数嵌套在另一个块或者函数中时，就发生了作用域的嵌套。<br>
遍历嵌套作用域连的规则： 引擎从当前执行的作用域开始查找变量，如果找不到就向上一级继续查找，当抵达到全局作用域时， 无论找到还是没有找到，查找过程都会停止。<br>
一个var变量产生的是函数级的作用域， let是块级作用域

#### 变量提升问题
变量和函数在内的所有声明都会在任何代码被执行前被处理， 也就是声明本身会被提升，而赋值或其他运算逻辑会停留在原地。
如下示例
```js
function foo () {
  console.log(a) // undefined
  var a = 2
}
```

#### 闭包

 正常的如果我们设置一个函数它会形成自己的作用域，当函数执行完成后其对应的作用域也会随之销毁。 而闭包具有存储其内部作用域的能力
如下示例 当我们执行test方法时可以拿到其内部作用域a所对应的值
```js
function foo () {
  var a = 33
  function getA () {
    return a
  }
  return getA
}
let test = foo()
```
应用场景： 闭包的应用在js的代码中可以说是随处可见。 比如你定义了一个高阶函数、一个偏函数、克里化方法、实现某个插件等等， 还有在webpack进行打包封装的时候都会应用的闭包方案
 
#### this指向情况

总的来说this的指向是当前函数的调用对象，再进一步可以划分如下

1. 当全局调用一个方法时 this指向当前环境如 window
2. 当直接定义一个字面量对象，调用其方法时this指向该对象
3. 通过apply call、bind方法可以将this指向其对应的借代对象
4. 通过new方法 this指向其new后的实例对象

```js 字面量对象示例
function foo () {
  console.log(a)
}
var obj = {
  a: 2, 
  foo: foo
}
obj.foo()
```

#### 原型链解释

#### new一个对象的过程

  首先了解new做了什么，使用new关键字调用函数（new ClassA(…)）的具体步骤：

　　1、创建一个新对象：

　　var obj = {};

　　2、设置新对象的constructor属性为构造函数的名称，设置新对象的__proto__属性指向构造函数的prototype对象；

　　obj.__proto__ = ClassA.prototype;

　　3、使用新对象调用函数，函数中的this被指向新实例对象：

　　ClassA.call(obj);　　//{}.构造函数()

　　4、将初始化完毕的新对象地址，保存到等号左边的变量中

